#  ✅ for ...in


## ✅ `for...in`에서 **"순서 보장 안 됨"**이란?

### 👉 자바스크립트는 객체 키를 아래 규칙에 따라 순회해:

### 🔸 객체 키 순서 규칙 (ES6 이후)
1. **숫자 형태의 키** (예: `"0"`, `"1"`, `"100"`)  
   → **오름차순** 정렬 후 먼저 출력됨

2. **문자열 키** (예: `"name"`, `"age"`)  
   → **작성한 순서대로** 출력됨 (단, 숫자 키보다 뒤에 나옴)

---

### 📌 예제 1: 문자열 키만 있는 경우

```js
const obj = {c: 3, a: 1, b: 2};

for (const key in obj) {
  console.log(key); // c → a → b  (작성한 순서대로 나옴)
}
```

✔️ 순서 유지됨. 하지만 이건 "우연히" 보장된 것처럼 보이는 상황이야.

---

### 📌 예제 2: 숫자 키가 섞인 경우

```js
const obj = {
  10: 'a',
  2: 'b',
  name: 'c',
  1: 'd'
};

for (const key in obj) {
  console.log(key); 
  // 출력: 1 → 2 → 10 → name
}
```

✔️ 숫자 키는 오름차순 → 그 다음에 문자열 키

---

### 🧠 그래서 왜 "순서를 보장하지 않는다"고 말하냐면?

> 객체에 숫자형 키와 문자열 키가 **혼합되었을 때**,  
> **작성 순서 그대로 출력되지 않기 때문**이야.

즉,
- 내가 `{a:1, b:2, c:3}` 이렇게 썼다고 해서 무조건 `a → b → c`가 나온다는 **보장이 없음**
- 내부적으로 **숫자 먼저, 그 다음 문자열**로 엔진이 순서 정리함
- 그래서 JS 개발자들은 `for...in`에서 **순서를 믿지 말라**고 하는 거야

---
<br>
<br>
<br>

# ✅ for...in, for...of에서 const 사용 예시
좋아! 두 번째 항목인 `for...in`, `for...of`에서 `const`를 써도 괜찮은 이유를 예시로 보여줄게. 핵심은 **변수를 재할당하는 게 아니라, 반복할 때마다 새로운 값을 자동으로 바인딩**해주기 때문이야.

---

##  `for...in`, `for...of`에서 const 사용 예시

### 📌 `for...of` 예시

```js
const arr = ['a', 'b', 'c'];

for (const item of arr) {
  console.log(item); // 'a', 'b', 'c'
}
```

- `item`은 **반복될 때마다 새로운 값**이 자동으로 `const item`에 바인딩됨.
- 그래서 `const`를 써도 에러가 발생하지 않음.
- 단, 아래처럼 `item`을 내부에서 재할당하면 **에러 발생**:

```js
for (const item of arr) {
  item = 'z';  // ❌ TypeError: Assignment to constant variable.
}
```

---

### 📌 `for...in` 예시

```js
const obj = { a: 1, b: 2, c: 3 };

for (const key in obj) {
  console.log(key); // 'a', 'b', 'c'
}
```

- 마찬가지로 `key`는 반복될 때마다 자동으로 새 키 값이 들어감.
- `const`이기 때문에 블록 내부에서 **값을 바꾸려 하면 에러**가 나.

---

### ✅ 결론

| 구문 | const 사용 가능? | 재할당 가능? |
|------|------------------|---------------|
| `for (let i = 0; …)` | ❌ 에러 발생 | i += 1 하니까 재할당 필요 |
| `for...of` / `for...in` | ✅ 사용 가능 | ❌ 내부에서 변수 바꾸면 에러 |

---
